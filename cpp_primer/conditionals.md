# Условные вычисления

В языке C++ существует два способа реализации вычислений с условиями:

1. Условная конструкция
2. Условный оператор

Первый способ следует использовать в большинстве случаев. Условный оператор - удобная конструкция, которую стоит использовать, если действие, описываемое условием, тривиально и требует только присвоения какой-то переменной определённую величину. Рассмотрим каждый из них.

## Условная конструкция

### Синтаксис конструкции

```c++
if (/*условие/*)
{
	/* блок кода, выполняемый, если значение условия - истина */
}
else
{
	/* блок кода, выполняемый, если значение условия - ложь */
}
```
### Запись условий

Условием может быть любое логическое или арифметическое (подразумевается целочисленная арифметика) выражение. В случае использования арифметического выражения значение 0 будет интерпретироваться как ложь, любое значение, отличное от нуля - как истина.

В записи условий применяются следующие операторы:

* ```a < b``` Истина, когда значение переменной или выражения ```a``` меньше, чем ```b```
* ```a > b``` Истина, когда значение переменной или выражения ```a``` больше, чем ```b```
* ```a <= b``` Истина, когда значение переменной или выражения ```a``` меньше или равно ```b```
* ```a >= b``` Истина, когда значение переменной или выражения ```a``` больше или равно ```b```
* ```a != b``` Истина, когда значение переменной или выражения ```a``` не равно ```b```
* ```a == b``` Истина, когда значение переменной или выражения ```a``` равно ```b```

**Обратите внимание!** В последнем выражении надо **обязательно** использовать два знака "равно", иначе в программе может засесть ошибка, **которую будет очень трудно найти**! Одинарный знак "=" означает "присвоение", причём оператор присвоения не только изменяет значение переменной, но и даёт значение, которое можно использовать в вычислениях (это требуется, например, для множественного присвоения: ```a = b = c = 0;```). Оператор присвоения **не должен** встречаться в условных конструкциях!

(Для любознательных: [пример программы с ошибкой](if-equals-error.md))

Для булевых (логических) значений также существует ряд операторов:

* ```a && b``` Логическое "и", истина, когда выражения ```a``` и ```b``` истинны
* ```a || b``` Логическое "или", истина, когда хотя бы одно из выражений ```a``` или ```b``` истинно
* ```!a``` Логическое "не", меняет значение логического выражения на противоположное (истину на ложь, ложь - на истину)

Остальные логические операторы возможно реализовать с использованием данных.

**Обратите внимание!** Операторы для логического "и" и "или" - сдвоенные. Одинарные операторы (```&``` и ```|```) используются для побитовых операций над целыми числами. Соответственно, первый оператор реализует побитовое "и" для двух чисел, второй - побитовое "или". **Не стоит надеяться на верную работу этих операторов с логическими выражениями!**

### Пример использования

(Решение для [задачи № 2960](http://informatics.mccme.ru/mod/statements/view3.php?id=276&chapterid=2960))

```c++
#include <iostream>

using namespace std;

int main()
{
    int test_ans; // Ответ, записанный в тестирующей системе
    int sch_ans;  // Ответ, данный школьником
    
    cin >> test_ans >> sch_ans;
    if ((test_ans == 1) && (sch_ans == 1))
    {
        cout << "YES" << endl;
    }
    else if ((test_ans != 1) && (sch_ans != 1))
    {
        cout << "YES" << endl;
    }
    else
    {
        cout << "NO" << endl;
    }
    
    return 0;
}
```

## Условный оператор

Условный оператор ```?:``` (также называемый *тернарным* - по количеству операндов) принимает значение *первого выражения*, если *условие* выполняется, иначе - значение *второго выражения*:
```c++
a = (условие) ? (первое выражение) : (второе выражение);
```
В указанном выше примере значение одного из выражений (в зависимости от условия) присваивается переменной ```a```.

Условный оператор имеет смысл использовать для каких-то простых операций, как то:

* Вычисление модуля числа: ``` abs_a = (a > 0) ? a : (-a);```
* Нахождение наибольшего из двух чисел: ```max_ab = (a > b) ? a : b;```
* Нахождение следующего чётного числа: ```next_even = (a % 0 == 0) ? (a + 2) : (a + 1);```

Использовать тернарный оператор для чего-то большего крайне не рекомендуется: его использование в менее тривиальных ситуациях делает код более трудночитаемым и увеличивает вероятность появления ошибок.